# Copyright (c) 2008 The Board of Trustees of The Leland Stanford Junior University
# Copyright (c) 2011, 2012 Open Networking Foundation
# Copyright (c) 2012, 2013 Big Switch Networks, Inc.
# See the file LICENSE.pyloxi which should have been included in the source distribution

# Automatically generated by LOXI from template module.py
# Do not modify

import struct
import loxi
import util
import loxi.generic_util

import sys
ofp = sys.modules['loxi.of15']

class port_desc_prop(loxi.OFObject):
    subtypes = {}


    def __init__(self, type=None):
        if type != None:
            self.type = type
        else:
            self.type = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!H', 0)
        subclass = port_desc_prop.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = port_desc_prop()
        obj.type = reader.read("!H")[0]
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.type != other.type: return False
        return True

    def pretty_print(self, q):
        q.text("port_desc_prop {")
        with q.group():
            with q.indent(2):
                q.breakable()
            q.breakable()
        q.text('}')


class experimenter(port_desc_prop):
    subtypes = {}

    type = 65535

    def __init__(self, experimenter=None, exp_type=None):
        if experimenter != None:
            self.experimenter = experimenter
        else:
            self.experimenter = 0
        if exp_type != None:
            self.exp_type = exp_type
        else:
            self.exp_type = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(struct.pack("!L", self.experimenter))
        packed.append(struct.pack("!L", self.exp_type))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!L', 4)
        subclass = experimenter.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = experimenter()
        _type = reader.read("!H")[0]
        assert(_type == 65535)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.experimenter = reader.read("!L")[0]
        obj.exp_type = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.experimenter != other.experimenter: return False
        if self.exp_type != other.exp_type: return False
        return True

    def pretty_print(self, q):
        q.text("experimenter {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("exp_type = ");
                q.text("%#x" % self.exp_type)
            q.breakable()
        q.text('}')

port_desc_prop.subtypes[65535] = experimenter

class bsn(experimenter):
    subtypes = {}

    type = 65535
    experimenter = 6035143

    def __init__(self, exp_type=None):
        if exp_type != None:
            self.exp_type = exp_type
        else:
            self.exp_type = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(struct.pack("!L", self.experimenter))
        packed.append(struct.pack("!L", self.exp_type))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!L', 8)
        subclass = bsn.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = bsn()
        _type = reader.read("!H")[0]
        assert(_type == 65535)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        _experimenter = reader.read("!L")[0]
        assert(_experimenter == 6035143)
        obj.exp_type = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.exp_type != other.exp_type: return False
        return True

    def pretty_print(self, q):
        q.text("bsn {")
        with q.group():
            with q.indent(2):
                q.breakable()
            q.breakable()
        q.text('}')

experimenter.subtypes[6035143] = bsn

class bsn_alarm(bsn):
    type = 65535
    experimenter = 6035143
    exp_type = 8

    def __init__(self, alarm_set=None, high=None, high_warn=None, low=None, low_warn=None, alarm_type=None, unit=None):
        if alarm_set != None:
            self.alarm_set = alarm_set
        else:
            self.alarm_set = 0
        if high != None:
            self.high = high
        else:
            self.high = 0
        if high_warn != None:
            self.high_warn = high_warn
        else:
            self.high_warn = 0
        if low != None:
            self.low = low
        else:
            self.low = 0
        if low_warn != None:
            self.low_warn = low_warn
        else:
            self.low_warn = 0
        if alarm_type != None:
            self.alarm_type = alarm_type
        else:
            self.alarm_type = 0
        if unit != None:
            self.unit = unit
        else:
            self.unit = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(struct.pack("!L", self.experimenter))
        packed.append(struct.pack("!L", self.exp_type))
        packed.append(struct.pack("!B", self.alarm_set))
        packed.append(struct.pack("!L", self.high))
        packed.append(struct.pack("!L", self.high_warn))
        packed.append(struct.pack("!L", self.low))
        packed.append(struct.pack("!L", self.low_warn))
        packed.append(struct.pack("!B", self.alarm_type))
        packed.append(struct.pack("!B", self.unit))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_alarm()
        _type = reader.read("!H")[0]
        assert(_type == 65535)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        _experimenter = reader.read("!L")[0]
        assert(_experimenter == 6035143)
        _exp_type = reader.read("!L")[0]
        assert(_exp_type == 8)
        obj.alarm_set = reader.read("!B")[0]
        obj.high = reader.read("!L")[0]
        obj.high_warn = reader.read("!L")[0]
        obj.low = reader.read("!L")[0]
        obj.low_warn = reader.read("!L")[0]
        obj.alarm_type = reader.read("!B")[0]
        obj.unit = reader.read("!B")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.alarm_set != other.alarm_set: return False
        if self.high != other.high: return False
        if self.high_warn != other.high_warn: return False
        if self.low != other.low: return False
        if self.low_warn != other.low_warn: return False
        if self.alarm_type != other.alarm_type: return False
        if self.unit != other.unit: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_alarm {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("alarm_set = ");
                q.text("%#x" % self.alarm_set)
                q.text(","); q.breakable()
                q.text("high = ");
                q.text("%#x" % self.high)
                q.text(","); q.breakable()
                q.text("high_warn = ");
                q.text("%#x" % self.high_warn)
                q.text(","); q.breakable()
                q.text("low = ");
                q.text("%#x" % self.low)
                q.text(","); q.breakable()
                q.text("low_warn = ");
                q.text("%#x" % self.low_warn)
                q.text(","); q.breakable()
                q.text("alarm_type = ");
                q.text("%#x" % self.alarm_type)
                q.text(","); q.breakable()
                q.text("unit = ");
                q.text("%#x" % self.unit)
            q.breakable()
        q.text('}')

bsn.subtypes[8] = bsn_alarm

class bsn_breakout(bsn):
    type = 65535
    experimenter = 6035143
    exp_type = 3

    def __init__(self, sub_interface_count=None, sub_interface_speed_gbps=None):
        if sub_interface_count != None:
            self.sub_interface_count = sub_interface_count
        else:
            self.sub_interface_count = 0
        if sub_interface_speed_gbps != None:
            self.sub_interface_speed_gbps = sub_interface_speed_gbps
        else:
            self.sub_interface_speed_gbps = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(struct.pack("!L", self.experimenter))
        packed.append(struct.pack("!L", self.exp_type))
        packed.append(struct.pack("!H", self.sub_interface_count))
        packed.append(struct.pack("!H", self.sub_interface_speed_gbps))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_breakout()
        _type = reader.read("!H")[0]
        assert(_type == 65535)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        _experimenter = reader.read("!L")[0]
        assert(_experimenter == 6035143)
        _exp_type = reader.read("!L")[0]
        assert(_exp_type == 3)
        obj.sub_interface_count = reader.read("!H")[0]
        obj.sub_interface_speed_gbps = reader.read("!H")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.sub_interface_count != other.sub_interface_count: return False
        if self.sub_interface_speed_gbps != other.sub_interface_speed_gbps: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_breakout {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("sub_interface_count = ");
                q.text("%#x" % self.sub_interface_count)
                q.text(","); q.breakable()
                q.text("sub_interface_speed_gbps = ");
                q.text("%#x" % self.sub_interface_speed_gbps)
            q.breakable()
        q.text('}')

bsn.subtypes[3] = bsn_breakout

class bsn_diag(bsn):
    type = 65535
    experimenter = 6035143
    exp_type = 7

    def __init__(self, laser_bias_curr=None, laser_output_power=None, laser_receiver_power_type=None, laser_receiver_power=None, module_temp=None, module_voltage=None):
        if laser_bias_curr != None:
            self.laser_bias_curr = laser_bias_curr
        else:
            self.laser_bias_curr = ofp.bsn_unit()
        if laser_output_power != None:
            self.laser_output_power = laser_output_power
        else:
            self.laser_output_power = ofp.bsn_unit()
        if laser_receiver_power_type != None:
            self.laser_receiver_power_type = laser_receiver_power_type
        else:
            self.laser_receiver_power_type = 0
        if laser_receiver_power != None:
            self.laser_receiver_power = laser_receiver_power
        else:
            self.laser_receiver_power = ofp.bsn_unit()
        if module_temp != None:
            self.module_temp = module_temp
        else:
            self.module_temp = ofp.bsn_unit()
        if module_voltage != None:
            self.module_voltage = module_voltage
        else:
            self.module_voltage = ofp.bsn_unit()
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(struct.pack("!L", self.experimenter))
        packed.append(struct.pack("!L", self.exp_type))
        packed.append(self.laser_bias_curr.pack())
        packed.append(self.laser_output_power.pack())
        packed.append(struct.pack("!B", self.laser_receiver_power_type))
        packed.append(self.laser_receiver_power.pack())
        packed.append(self.module_temp.pack())
        packed.append(self.module_voltage.pack())
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_diag()
        _type = reader.read("!H")[0]
        assert(_type == 65535)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        _experimenter = reader.read("!L")[0]
        assert(_experimenter == 6035143)
        _exp_type = reader.read("!L")[0]
        assert(_exp_type == 7)
        obj.laser_bias_curr = ofp.bsn_unit.unpack(reader)
        obj.laser_output_power = ofp.bsn_unit.unpack(reader)
        obj.laser_receiver_power_type = reader.read("!B")[0]
        obj.laser_receiver_power = ofp.bsn_unit.unpack(reader)
        obj.module_temp = ofp.bsn_unit.unpack(reader)
        obj.module_voltage = ofp.bsn_unit.unpack(reader)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.laser_bias_curr != other.laser_bias_curr: return False
        if self.laser_output_power != other.laser_output_power: return False
        if self.laser_receiver_power_type != other.laser_receiver_power_type: return False
        if self.laser_receiver_power != other.laser_receiver_power: return False
        if self.module_temp != other.module_temp: return False
        if self.module_voltage != other.module_voltage: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_diag {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("laser_bias_curr = ");
                q.pp(self.laser_bias_curr)
                q.text(","); q.breakable()
                q.text("laser_output_power = ");
                q.pp(self.laser_output_power)
                q.text(","); q.breakable()
                q.text("laser_receiver_power_type = ");
                q.text("%#x" % self.laser_receiver_power_type)
                q.text(","); q.breakable()
                q.text("laser_receiver_power = ");
                q.pp(self.laser_receiver_power)
                q.text(","); q.breakable()
                q.text("module_temp = ");
                q.pp(self.module_temp)
                q.text(","); q.breakable()
                q.text("module_voltage = ");
                q.pp(self.module_voltage)
            q.breakable()
        q.text('}')

bsn.subtypes[7] = bsn_diag

class bsn_ethtool(bsn):
    type = 65535
    experimenter = 6035143
    exp_type = 6

    def __init__(self, identifier=None, extidentifier=None, connector=None, transdata=None, encoding=None, br_nominal=None, rateidentifier=None, length_SMF_KM=None, length_SMF=None, length_50_um=None, length_625_um=None, length_copper=None, length_OM3=None, vendor_name_lo=None, vendor_name_hi=None, vendor_oui=None, vendor_pn_lo=None, vendor_pn_hi=None, vendor_rev=None, more_properties=None):
        if identifier != None:
            self.identifier = identifier
        else:
            self.identifier = 0
        if extidentifier != None:
            self.extidentifier = extidentifier
        else:
            self.extidentifier = 0
        if connector != None:
            self.connector = connector
        else:
            self.connector = 0
        if transdata != None:
            self.transdata = transdata
        else:
            self.transdata = ofp.bsn_module_eeprom_transceiver()
        if encoding != None:
            self.encoding = encoding
        else:
            self.encoding = 0
        if br_nominal != None:
            self.br_nominal = br_nominal
        else:
            self.br_nominal = ofp.bsn_unit()
        if rateidentifier != None:
            self.rateidentifier = rateidentifier
        else:
            self.rateidentifier = 0
        if length_SMF_KM != None:
            self.length_SMF_KM = length_SMF_KM
        else:
            self.length_SMF_KM = ofp.bsn_unit()
        if length_SMF != None:
            self.length_SMF = length_SMF
        else:
            self.length_SMF = ofp.bsn_unit()
        if length_50_um != None:
            self.length_50_um = length_50_um
        else:
            self.length_50_um = ofp.bsn_unit()
        if length_625_um != None:
            self.length_625_um = length_625_um
        else:
            self.length_625_um = ofp.bsn_unit()
        if length_copper != None:
            self.length_copper = length_copper
        else:
            self.length_copper = ofp.bsn_unit()
        if length_OM3 != None:
            self.length_OM3 = length_OM3
        else:
            self.length_OM3 = ofp.bsn_unit()
        if vendor_name_lo != None:
            self.vendor_name_lo = vendor_name_lo
        else:
            self.vendor_name_lo = 0
        if vendor_name_hi != None:
            self.vendor_name_hi = vendor_name_hi
        else:
            self.vendor_name_hi = 0
        if vendor_oui != None:
            self.vendor_oui = vendor_oui
        else:
            self.vendor_oui = 0
        if vendor_pn_lo != None:
            self.vendor_pn_lo = vendor_pn_lo
        else:
            self.vendor_pn_lo = 0
        if vendor_pn_hi != None:
            self.vendor_pn_hi = vendor_pn_hi
        else:
            self.vendor_pn_hi = 0
        if vendor_rev != None:
            self.vendor_rev = vendor_rev
        else:
            self.vendor_rev = 0
        if more_properties != None:
            self.more_properties = more_properties
        else:
            self.more_properties = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(struct.pack("!L", self.experimenter))
        packed.append(struct.pack("!L", self.exp_type))
        packed.append(struct.pack("!B", self.identifier))
        packed.append(struct.pack("!B", self.extidentifier))
        packed.append(struct.pack("!B", self.connector))
        packed.append(self.transdata.pack())
        packed.append(struct.pack("!B", self.encoding))
        packed.append(self.br_nominal.pack())
        packed.append(struct.pack("!B", self.rateidentifier))
        packed.append(self.length_SMF_KM.pack())
        packed.append(self.length_SMF.pack())
        packed.append(self.length_50_um.pack())
        packed.append(self.length_625_um.pack())
        packed.append(self.length_copper.pack())
        packed.append(self.length_OM3.pack())
        packed.append(struct.pack("!Q", self.vendor_name_lo))
        packed.append(struct.pack("!Q", self.vendor_name_hi))
        packed.append(struct.pack("!L", self.vendor_oui))
        packed.append(struct.pack("!Q", self.vendor_pn_lo))
        packed.append(struct.pack("!Q", self.vendor_pn_hi))
        packed.append(struct.pack("!L", self.vendor_rev))
        packed.append(loxi.generic_util.pack_list(self.more_properties))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_ethtool()
        _type = reader.read("!H")[0]
        assert(_type == 65535)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        _experimenter = reader.read("!L")[0]
        assert(_experimenter == 6035143)
        _exp_type = reader.read("!L")[0]
        assert(_exp_type == 6)
        obj.identifier = reader.read("!B")[0]
        obj.extidentifier = reader.read("!B")[0]
        obj.connector = reader.read("!B")[0]
        obj.transdata = ofp.bsn_module_eeprom_transceiver.unpack(reader)
        obj.encoding = reader.read("!B")[0]
        obj.br_nominal = ofp.bsn_unit.unpack(reader)
        obj.rateidentifier = reader.read("!B")[0]
        obj.length_SMF_KM = ofp.bsn_unit.unpack(reader)
        obj.length_SMF = ofp.bsn_unit.unpack(reader)
        obj.length_50_um = ofp.bsn_unit.unpack(reader)
        obj.length_625_um = ofp.bsn_unit.unpack(reader)
        obj.length_copper = ofp.bsn_unit.unpack(reader)
        obj.length_OM3 = ofp.bsn_unit.unpack(reader)
        obj.vendor_name_lo = reader.read("!Q")[0]
        obj.vendor_name_hi = reader.read("!Q")[0]
        obj.vendor_oui = reader.read("!L")[0]
        obj.vendor_pn_lo = reader.read("!Q")[0]
        obj.vendor_pn_hi = reader.read("!Q")[0]
        obj.vendor_rev = reader.read("!L")[0]
        obj.more_properties = loxi.generic_util.unpack_list(reader, ofp.port_desc_prop.port_desc_prop.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.identifier != other.identifier: return False
        if self.extidentifier != other.extidentifier: return False
        if self.connector != other.connector: return False
        if self.transdata != other.transdata: return False
        if self.encoding != other.encoding: return False
        if self.br_nominal != other.br_nominal: return False
        if self.rateidentifier != other.rateidentifier: return False
        if self.length_SMF_KM != other.length_SMF_KM: return False
        if self.length_SMF != other.length_SMF: return False
        if self.length_50_um != other.length_50_um: return False
        if self.length_625_um != other.length_625_um: return False
        if self.length_copper != other.length_copper: return False
        if self.length_OM3 != other.length_OM3: return False
        if self.vendor_name_lo != other.vendor_name_lo: return False
        if self.vendor_name_hi != other.vendor_name_hi: return False
        if self.vendor_oui != other.vendor_oui: return False
        if self.vendor_pn_lo != other.vendor_pn_lo: return False
        if self.vendor_pn_hi != other.vendor_pn_hi: return False
        if self.vendor_rev != other.vendor_rev: return False
        if self.more_properties != other.more_properties: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_ethtool {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("identifier = ");
                q.text("%#x" % self.identifier)
                q.text(","); q.breakable()
                q.text("extidentifier = ");
                q.text("%#x" % self.extidentifier)
                q.text(","); q.breakable()
                q.text("connector = ");
                q.text("%#x" % self.connector)
                q.text(","); q.breakable()
                q.text("transdata = ");
                q.pp(self.transdata)
                q.text(","); q.breakable()
                q.text("encoding = ");
                q.text("%#x" % self.encoding)
                q.text(","); q.breakable()
                q.text("br_nominal = ");
                q.pp(self.br_nominal)
                q.text(","); q.breakable()
                q.text("rateidentifier = ");
                q.text("%#x" % self.rateidentifier)
                q.text(","); q.breakable()
                q.text("length_SMF_KM = ");
                q.pp(self.length_SMF_KM)
                q.text(","); q.breakable()
                q.text("length_SMF = ");
                q.pp(self.length_SMF)
                q.text(","); q.breakable()
                q.text("length_50_um = ");
                q.pp(self.length_50_um)
                q.text(","); q.breakable()
                q.text("length_625_um = ");
                q.pp(self.length_625_um)
                q.text(","); q.breakable()
                q.text("length_copper = ");
                q.pp(self.length_copper)
                q.text(","); q.breakable()
                q.text("length_OM3 = ");
                q.pp(self.length_OM3)
                q.text(","); q.breakable()
                q.text("vendor_name_lo = ");
                q.text("%#x" % self.vendor_name_lo)
                q.text(","); q.breakable()
                q.text("vendor_name_hi = ");
                q.text("%#x" % self.vendor_name_hi)
                q.text(","); q.breakable()
                q.text("vendor_oui = ");
                q.text("%#x" % self.vendor_oui)
                q.text(","); q.breakable()
                q.text("vendor_pn_lo = ");
                q.text("%#x" % self.vendor_pn_lo)
                q.text(","); q.breakable()
                q.text("vendor_pn_hi = ");
                q.text("%#x" % self.vendor_pn_hi)
                q.text(","); q.breakable()
                q.text("vendor_rev = ");
                q.text("%#x" % self.vendor_rev)
                q.text(","); q.breakable()
                q.text("more_properties = ");
                q.pp(self.more_properties)
            q.breakable()
        q.text('}')

bsn.subtypes[6] = bsn_ethtool

class bsn_forward_error_correction(bsn):
    type = 65535
    experimenter = 6035143
    exp_type = 2

    def __init__(self, configured=None, enabled=None):
        if configured != None:
            self.configured = configured
        else:
            self.configured = 0
        if enabled != None:
            self.enabled = enabled
        else:
            self.enabled = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(struct.pack("!L", self.experimenter))
        packed.append(struct.pack("!L", self.exp_type))
        packed.append(struct.pack("!L", self.configured))
        packed.append(struct.pack("!L", self.enabled))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_forward_error_correction()
        _type = reader.read("!H")[0]
        assert(_type == 65535)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        _experimenter = reader.read("!L")[0]
        assert(_experimenter == 6035143)
        _exp_type = reader.read("!L")[0]
        assert(_exp_type == 2)
        obj.configured = reader.read("!L")[0]
        obj.enabled = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.configured != other.configured: return False
        if self.enabled != other.enabled: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_forward_error_correction {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("configured = ");
                q.text("%#x" % self.configured)
                q.text(","); q.breakable()
                q.text("enabled = ");
                q.text("%#x" % self.enabled)
            q.breakable()
        q.text('}')

bsn.subtypes[2] = bsn_forward_error_correction

class bsn_generation_id(bsn):
    type = 65535
    experimenter = 6035143
    exp_type = 1

    def __init__(self, generation_id=None):
        if generation_id != None:
            self.generation_id = generation_id
        else:
            self.generation_id = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(struct.pack("!L", self.experimenter))
        packed.append(struct.pack("!L", self.exp_type))
        packed.append(struct.pack("!Q", self.generation_id))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_generation_id()
        _type = reader.read("!H")[0]
        assert(_type == 65535)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        _experimenter = reader.read("!L")[0]
        assert(_experimenter == 6035143)
        _exp_type = reader.read("!L")[0]
        assert(_exp_type == 1)
        obj.generation_id = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.generation_id != other.generation_id: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_generation_id {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("generation_id = ");
                q.text("%#x" % self.generation_id)
            q.breakable()
        q.text('}')

bsn.subtypes[1] = bsn_generation_id

class bsn_misc_capabilities(bsn):
    type = 65535
    experimenter = 6035143
    exp_type = 5

    def __init__(self, current=None, available=None, supported=None):
        if current != None:
            self.current = current
        else:
            self.current = 0
        if available != None:
            self.available = available
        else:
            self.available = 0
        if supported != None:
            self.supported = supported
        else:
            self.supported = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(struct.pack("!L", self.experimenter))
        packed.append(struct.pack("!L", self.exp_type))
        packed.append(struct.pack("!Q", self.current))
        packed.append(struct.pack("!Q", self.available))
        packed.append(struct.pack("!Q", self.supported))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_misc_capabilities()
        _type = reader.read("!H")[0]
        assert(_type == 65535)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        _experimenter = reader.read("!L")[0]
        assert(_experimenter == 6035143)
        _exp_type = reader.read("!L")[0]
        assert(_exp_type == 5)
        obj.current = reader.read("!Q")[0]
        obj.available = reader.read("!Q")[0]
        obj.supported = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.current != other.current: return False
        if self.available != other.available: return False
        if self.supported != other.supported: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_misc_capabilities {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("current = ");
                q.text("%#x" % self.current)
                q.text(","); q.breakable()
                q.text("available = ");
                q.text("%#x" % self.available)
                q.text(","); q.breakable()
                q.text("supported = ");
                q.text("%#x" % self.supported)
            q.breakable()
        q.text('}')

bsn.subtypes[5] = bsn_misc_capabilities

class bsn_speed_capabilities(bsn):
    type = 65535
    experimenter = 6035143
    exp_type = 4

    def __init__(self, current=None, available=None, supported=None):
        if current != None:
            self.current = current
        else:
            self.current = 0
        if available != None:
            self.available = available
        else:
            self.available = 0
        if supported != None:
            self.supported = supported
        else:
            self.supported = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(struct.pack("!L", self.experimenter))
        packed.append(struct.pack("!L", self.exp_type))
        packed.append(struct.pack("!Q", self.current))
        packed.append(struct.pack("!Q", self.available))
        packed.append(struct.pack("!Q", self.supported))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_speed_capabilities()
        _type = reader.read("!H")[0]
        assert(_type == 65535)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        _experimenter = reader.read("!L")[0]
        assert(_experimenter == 6035143)
        _exp_type = reader.read("!L")[0]
        assert(_exp_type == 4)
        obj.current = reader.read("!Q")[0]
        obj.available = reader.read("!Q")[0]
        obj.supported = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.current != other.current: return False
        if self.available != other.available: return False
        if self.supported != other.supported: return False
        return True

    def pretty_print(self, q):
        q.text("bsn_speed_capabilities {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("current = ");
                q.text("%#x" % self.current)
                q.text(","); q.breakable()
                q.text("available = ");
                q.text("%#x" % self.available)
                q.text(","); q.breakable()
                q.text("supported = ");
                q.text("%#x" % self.supported)
            q.breakable()
        q.text('}')

bsn.subtypes[4] = bsn_speed_capabilities

class bsn_uplink(bsn):
    type = 65535
    experimenter = 6035143
    exp_type = 0

    def __init__(self):
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append(struct.pack("!L", self.experimenter))
        packed.append(struct.pack("!L", self.exp_type))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bsn_uplink()
        _type = reader.read("!H")[0]
        assert(_type == 65535)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        _experimenter = reader.read("!L")[0]
        assert(_experimenter == 6035143)
        _exp_type = reader.read("!L")[0]
        assert(_exp_type == 0)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        return True

    def pretty_print(self, q):
        q.text("bsn_uplink {")
        with q.group():
            with q.indent(2):
                q.breakable()
            q.breakable()
        q.text('}')

bsn.subtypes[0] = bsn_uplink

class ethernet(port_desc_prop):
    type = 0

    def __init__(self, curr=None, advertised=None, supported=None, peer=None, curr_speed=None, max_speed=None):
        if curr != None:
            self.curr = curr
        else:
            self.curr = 0
        if advertised != None:
            self.advertised = advertised
        else:
            self.advertised = 0
        if supported != None:
            self.supported = supported
        else:
            self.supported = 0
        if peer != None:
            self.peer = peer
        else:
            self.peer = 0
        if curr_speed != None:
            self.curr_speed = curr_speed
        else:
            self.curr_speed = 0
        if max_speed != None:
            self.max_speed = max_speed
        else:
            self.max_speed = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append('\x00' * 4)
        packed.append(struct.pack("!L", self.curr))
        packed.append(struct.pack("!L", self.advertised))
        packed.append(struct.pack("!L", self.supported))
        packed.append(struct.pack("!L", self.peer))
        packed.append(struct.pack("!L", self.curr_speed))
        packed.append(struct.pack("!L", self.max_speed))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = ethernet()
        _type = reader.read("!H")[0]
        assert(_type == 0)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        reader.skip(4)
        obj.curr = reader.read("!L")[0]
        obj.advertised = reader.read("!L")[0]
        obj.supported = reader.read("!L")[0]
        obj.peer = reader.read("!L")[0]
        obj.curr_speed = reader.read("!L")[0]
        obj.max_speed = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.curr != other.curr: return False
        if self.advertised != other.advertised: return False
        if self.supported != other.supported: return False
        if self.peer != other.peer: return False
        if self.curr_speed != other.curr_speed: return False
        if self.max_speed != other.max_speed: return False
        return True

    def pretty_print(self, q):
        q.text("ethernet {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("curr = ");
                q.text("%#x" % self.curr)
                q.text(","); q.breakable()
                q.text("advertised = ");
                q.text("%#x" % self.advertised)
                q.text(","); q.breakable()
                q.text("supported = ");
                q.text("%#x" % self.supported)
                q.text(","); q.breakable()
                q.text("peer = ");
                q.text("%#x" % self.peer)
                q.text(","); q.breakable()
                q.text("curr_speed = ");
                q.text("%#x" % self.curr_speed)
                q.text(","); q.breakable()
                q.text("max_speed = ");
                q.text("%#x" % self.max_speed)
            q.breakable()
        q.text('}')

port_desc_prop.subtypes[0] = ethernet

class optical(port_desc_prop):
    type = 1

    def __init__(self, supported=None, tx_min_freq_lmda=None, tx_max_freq_lmda=None, tx_grid_freq_lmda=None, rx_min_freq_lmda=None, rx_max_freq_lmda=None, rx_grid_freq_lmda=None, tx_pwr_min=None, tx_pwr_max=None):
        if supported != None:
            self.supported = supported
        else:
            self.supported = 0
        if tx_min_freq_lmda != None:
            self.tx_min_freq_lmda = tx_min_freq_lmda
        else:
            self.tx_min_freq_lmda = 0
        if tx_max_freq_lmda != None:
            self.tx_max_freq_lmda = tx_max_freq_lmda
        else:
            self.tx_max_freq_lmda = 0
        if tx_grid_freq_lmda != None:
            self.tx_grid_freq_lmda = tx_grid_freq_lmda
        else:
            self.tx_grid_freq_lmda = 0
        if rx_min_freq_lmda != None:
            self.rx_min_freq_lmda = rx_min_freq_lmda
        else:
            self.rx_min_freq_lmda = 0
        if rx_max_freq_lmda != None:
            self.rx_max_freq_lmda = rx_max_freq_lmda
        else:
            self.rx_max_freq_lmda = 0
        if rx_grid_freq_lmda != None:
            self.rx_grid_freq_lmda = rx_grid_freq_lmda
        else:
            self.rx_grid_freq_lmda = 0
        if tx_pwr_min != None:
            self.tx_pwr_min = tx_pwr_min
        else:
            self.tx_pwr_min = 0
        if tx_pwr_max != None:
            self.tx_pwr_max = tx_pwr_max
        else:
            self.tx_pwr_max = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 1
        packed.append('\x00' * 4)
        packed.append(struct.pack("!L", self.supported))
        packed.append(struct.pack("!L", self.tx_min_freq_lmda))
        packed.append(struct.pack("!L", self.tx_max_freq_lmda))
        packed.append(struct.pack("!L", self.tx_grid_freq_lmda))
        packed.append(struct.pack("!L", self.rx_min_freq_lmda))
        packed.append(struct.pack("!L", self.rx_max_freq_lmda))
        packed.append(struct.pack("!L", self.rx_grid_freq_lmda))
        packed.append(struct.pack("!L", self.tx_pwr_min))
        packed.append(struct.pack("!L", self.tx_pwr_max))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = optical()
        _type = reader.read("!H")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        reader.skip(4)
        obj.supported = reader.read("!L")[0]
        obj.tx_min_freq_lmda = reader.read("!L")[0]
        obj.tx_max_freq_lmda = reader.read("!L")[0]
        obj.tx_grid_freq_lmda = reader.read("!L")[0]
        obj.rx_min_freq_lmda = reader.read("!L")[0]
        obj.rx_max_freq_lmda = reader.read("!L")[0]
        obj.rx_grid_freq_lmda = reader.read("!L")[0]
        obj.tx_pwr_min = reader.read("!L")[0]
        obj.tx_pwr_max = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.supported != other.supported: return False
        if self.tx_min_freq_lmda != other.tx_min_freq_lmda: return False
        if self.tx_max_freq_lmda != other.tx_max_freq_lmda: return False
        if self.tx_grid_freq_lmda != other.tx_grid_freq_lmda: return False
        if self.rx_min_freq_lmda != other.rx_min_freq_lmda: return False
        if self.rx_max_freq_lmda != other.rx_max_freq_lmda: return False
        if self.rx_grid_freq_lmda != other.rx_grid_freq_lmda: return False
        if self.tx_pwr_min != other.tx_pwr_min: return False
        if self.tx_pwr_max != other.tx_pwr_max: return False
        return True

    def pretty_print(self, q):
        q.text("optical {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("supported = ");
                q.text("%#x" % self.supported)
                q.text(","); q.breakable()
                q.text("tx_min_freq_lmda = ");
                q.text("%#x" % self.tx_min_freq_lmda)
                q.text(","); q.breakable()
                q.text("tx_max_freq_lmda = ");
                q.text("%#x" % self.tx_max_freq_lmda)
                q.text(","); q.breakable()
                q.text("tx_grid_freq_lmda = ");
                q.text("%#x" % self.tx_grid_freq_lmda)
                q.text(","); q.breakable()
                q.text("rx_min_freq_lmda = ");
                q.text("%#x" % self.rx_min_freq_lmda)
                q.text(","); q.breakable()
                q.text("rx_max_freq_lmda = ");
                q.text("%#x" % self.rx_max_freq_lmda)
                q.text(","); q.breakable()
                q.text("rx_grid_freq_lmda = ");
                q.text("%#x" % self.rx_grid_freq_lmda)
                q.text(","); q.breakable()
                q.text("tx_pwr_min = ");
                q.text("%#x" % self.tx_pwr_min)
                q.text(","); q.breakable()
                q.text("tx_pwr_max = ");
                q.text("%#x" % self.tx_pwr_max)
            q.breakable()
        q.text('}')

port_desc_prop.subtypes[1] = optical


